(NUMBER)
"PER BRINCH HANSEN

 INFORMATION SCIENCE
 CALIFORNIA INSTITUTE OF TECHNOLOGY

 UTILITY PROGRAMS FOR
 THE SOLO SYSTEM

 18 MAY 1975"

"###########
#  PREFIX  #
###########"


CONST NL = '(:10:)';   FF = '(:12:)';   CR = '(:13:)';   EM = '(:25:)';

CONST PAGELENGTH = 512;
TYPE PAGE = ARRAY (.1..PAGELENGTH.) OF CHAR;

CONST LINELENGTH = 132;
TYPE LINE = ARRAY (.1..LINELENGTH.) OF CHAR;

CONST IDLENGTH = 12;
TYPE IDENTIFIER = ARRAY (.1..IDLENGTH.) OF CHAR;

TYPE FILE = 1..2;

TYPE FILEKIND = (EMPTY, SCRATCH, ASCII, SEQCODE, CONCODE);

TYPE FILEATTR = RECORD
                  KIND: FILEKIND;
                  ADDR: INTEGER;
                  PROTECTED: BOOLEAN;
                  NOTUSED: ARRAY (.1..5.) OF INTEGER
                END;

TYPE IODEVICE =
  (TYPEDEVICE, DISKDEVICE, TAPEDEVICE, PRINTDEVICE, CARDDEVICE);

TYPE IOOPERATION = (INPUT, OUTPUT, MOVE, CONTROL);

TYPE IOARG = (WRITEEOF, REWIND, UPSPACE, BACKSPACE);

TYPE IORESULT =
  (COMPLETE, INTERVENTION, TRANSMISSION, FAILURE,
   ENDFILE, ENDMEDIUM, STARTMEDIUM);

TYPE IOPARAM = RECORD
                 OPERATION: IOOPERATION;
                 STATUS: IORESULT;
                 ARG: IOARG
               END;

TYPE TASKKIND = (INPUTTASK, JOBTASK, OUTPUTTASK);

TYPE ARGTAG =
  (NILTYPE, BOOLTYPE, INTTYPE, IDTYPE, PTRTYPE);

TYPE POINTER = @BOOLEAN;

TYPE ARGTYPE = RECORD
                 CASE TAG: ARGTAG OF
                   NILTYPE, BOOLTYPE: (BOOL: BOOLEAN);
                   INTTYPE: (INT: INTEGER);
                   IDTYPE: (ID: IDENTIFIER);
                   PTRTYPE: (PTR: POINTER)
               END;

CONST MAXARG = 10;
TYPE ARGLIST = ARRAY (.1..MAXARG.) OF ARGTYPE;

TYPE ARGSEQ = (INP, OUT);

TYPE PROGRESULT =
  (TERMINATED, OVERFLOW, POINTERERROR, RANGEERROR, VARIANTERROR,
   HEAPLIMIT, STACKLIMIT, CODELIMIT, TIMELIMIT, CALLERROR);

PROCEDURE READ(VAR C: CHAR);
PROCEDURE WRITE(C: CHAR);

PROCEDURE OPEN(F: FILE; ID: IDENTIFIER; VAR FOUND: BOOLEAN);
PROCEDURE CLOSE(F: FILE);
PROCEDURE GET(F: FILE; P: INTEGER; VAR BLOCK: UNIV PAGE);
PROCEDURE PUT(F: FILE; P: INTEGER; VAR BLOCK: UNIV PAGE);
FUNCTION LENGTH(F: FILE): INTEGER;

PROCEDURE MARK(VAR TOP: INTEGER);
PROCEDURE RELEASE(TOP: INTEGER);

PROCEDURE IDENTIFY(HEADER: LINE);
PROCEDURE ACCEPT(VAR C: CHAR);
PROCEDURE DISPLAY(C: CHAR);

PROCEDURE READPAGE(VAR BLOCK: UNIV PAGE; VAR EOF: BOOLEAN);
PROCEDURE WRITEPAGE(BLOCK: UNIV PAGE; EOF: BOOLEAN);
PROCEDURE READLINE(VAR TEXT: UNIV LINE);
PROCEDURE WRITELINE(TEXT: UNIV LINE);
PROCEDURE READARG(S: ARGSEQ; VAR ARG: ARGTYPE);
PROCEDURE WRITEARG(S: ARGSEQ; ARG: ARGTYPE);

PROCEDURE LOOKUP(ID: IDENTIFIER; VAR ATTR: FILEATTR; VAR FOUND: BOOLEAN);

PROCEDURE IOTRANSFER
  (DEVICE: IODEVICE; VAR PARAM: IOPARAM; VAR BLOCK: UNIV PAGE);

PROCEDURE IOMOVE(DEVICE: IODEVICE; VAR PARAM: IOPARAM);

FUNCTION TASK: TASKKIND;

PROCEDURE RUN(ID: IDENTIFIER; VAR PARAM: ARGLIST;
              VAR LINE: INTEGER; VAR RESULT: PROGRESULT);


PROGRAM P(VAR PARAM: ARGLIST);



"####################################################
#  EDIT(VAR OK: BOOLEAN; SOURCE, DEST: IDENTIFIER)  #
####################################################"


"INSERT PREFIX HERE"

TYPE

COMMANDTYPE = (INSERT, DELETE, COPY);

BUFINDEX = 1..1024;
BUFFER = ARRAY (.BUFINDEX.) OF CHAR;
BUFPAIR = ARRAY (.1..2.) OF PAGE;

VAR

SOURCE, DEST: ARGTYPE;
OK, EOF: BOOLEAN;
WHERE: (NOWHERE, ONDISK, ELSEWHERE);
LENGTH: INTEGER;
TEXT: LINE; LINENO, CHARNO: INTEGER;
NLOREM, DIGIT, DIGITORNL: SET OF CHAR;

FROM: BUFFER; X: BUFINDEX;
TO_: BUFFER; Y: BUFINDEX;
LASTPAGE: BOOLEAN;



PROCEDURE WRITETEXT(TEXT: LINE);
VAR I: INTEGER; C: CHAR;
BEGIN
  I:= 0;
  REPEAT
    I:= I + 1;
    C:= TEXT(.I.);
    DISPLAY(C);
  UNTIL C = NL;
END;

PROCEDURE ERROR(TEXT: LINE);
BEGIN
  WRITETEXT(TEXT);
  OK:= FALSE;
END;

PROCEDURE WARNING(TEXT: LINE);
BEGIN
  WRITETEXT(TEXT);
  OK:= TRUE;
END;

PROCEDURE HELP;
BEGIN
  IF OK THEN
  BEGIN
    WRITETEXT('TRY AGAIN(:10:)');
    WRITETEXT('     EDIT(FILE: IDENTIFIER)(:10:)');
    WRITETEXT('OR (:10:)');
    WRITETEXT('     EDIT(SOURCE, DESTINATION: IDENTIFIER) (:10:)');
    OK:= FALSE;
  END;
END;

PROCEDURE READTEXT;
VAR I: INTEGER; C: CHAR;
BEGIN
  I:= 0;
  REPEAT
    I:= I + 1;
    ACCEPT(C);
    TEXT(.I.):= C;
  UNTIL C = NL;
  CHARNO:= 1;
END;

PROCEDURE SAVEFILE;
VAR LINE: INTEGER; RESULT: PROGRESULT;
    LIST: ARGLIST;
BEGIN
  WITH LIST(.1.) DO
  BEGIN TAG:= BOOLTYPE; BOOL:= FALSE END;
  WITH LIST(.2.) DO
  BEGIN TAG:= IDTYPE;
    IF WHERE = NOWHERE THEN ID:= 'CREATE      '
                       ELSE ID:= 'REPLACE     ';
  END;
  WITH LIST(.3.) DO
  BEGIN TAG:= IDTYPE; ID:= DEST.ID END;
  WITH LIST(.4.) DO
  BEGIN TAG:= INTTYPE; INT:= LENGTH END;
  WITH LIST(.5.) DO
  BEGIN TAG:= IDTYPE; ID:= 'ASCII       ' END;
  WITH LIST(.6.) DO
  BEGIN TAG:= BOOLTYPE; BOOL:= FALSE END;
  RUN('FILE        ', LIST, LINE, RESULT);
  IDENTIFY('EDIT:(:10:)');
  IF (RESULT <> TERMINATED) OR
    NOT LIST(.1.).BOOL
    THEN ERROR('DESTINATION FILE LOST(:10:)');
END;

PROCEDURE CHECKARG;
VAR ATTR: FILEATTR; FOUND: BOOLEAN;
BEGIN
  SOURCE:= PARAM(.2.);
  WITH SOURCE DO
  IF TAG <> IDTYPE THEN HELP ELSE
  BEGIN
    LOOKUP(ID, ATTR, FOUND);
    IF NOT FOUND THEN
      ERROR('SOURCE FILE UNKNOWN(:10:)') ELSE
    CASE ATTR.KIND OF
      SCRATCH, CONCODE:
        ERROR('SOURCE KIND MUST BE ASCII OR SEQCODE (:10:)');
      ASCII, SEQCODE:
    END;
  END;
  DEST:= PARAM(.3.);
  IF DEST.TAG = NILTYPE THEN
    DEST:= SOURCE;
  WITH DEST DO
  IF TAG <> IDTYPE THEN HELP ELSE
  BEGIN
    LOOKUP(ID, ATTR, FOUND);
    IF NOT FOUND THEN
      WHERE:= NOWHERE ELSE
    IF ATTR.KIND = SEQCODE THEN
      WHERE:= ELSEWHERE ELSE
    IF ATTR.PROTECTED THEN
      ERROR('DESTINATION FILE PROTECTED (:10:)') ELSE
      WHERE:= ONDISK;
  END;
END;

PROCEDURE INITIO;
VAR ARG: ARGTYPE;
BEGIN
  WRITEARG(INP, SOURCE);
  IF WHERE = ELSEWHERE THEN
    WRITEARG(OUT, DEST) ELSE
    BEGIN
      WITH ARG DO
      BEGIN TAG:= IDTYPE; ID:= 'NEXT        ' END;
      WRITEARG(OUT, ARG);
    END;
END;

PROCEDURE CHECKIO;
VAR ARG: ARGTYPE;
BEGIN
  READARG(INP, ARG);
  IF NOT ARG.BOOL THEN OK:= FALSE;
  IF WHERE <> ELSEWHERE THEN
  BEGIN READARG(OUT, ARG); LENGTH:= ARG.INT END;
  READARG(OUT, ARG);
  IF NOT ARG.BOOL THEN OK:= FALSE;
  IF (WHERE <> ELSEWHERE) & OK THEN SAVEFILE;
END;

PROCEDURE SCANINT(VAR I: INTEGER);
BEGIN
  WHILE NOT (TEXT(.CHARNO.) IN DIGITORNL) DO
    CHARNO:= CHARNO + 1;
  IF TEXT(.CHARNO.) IN DIGIT THEN
  BEGIN
    I:= 0;
    REPEAT
      I:= 10*I + ORD(TEXT(.CHARNO.)) - ORD('0');
      CHARNO:= CHARNO + 1;
    UNTIL NOT (TEXT(.CHARNO.) IN DIGIT);
  END ELSE
    OK:= FALSE;
END;

FUNCTION STARTSWITH(WHAT: LINE): BOOLEAN;
VAR I, J: INTEGER;
BEGIN
  I:= 1;
  WHILE TEXT(.I.) = ' ' DO I:= I + 1;
  STARTSWITH:= TRUE; J:= 1;
  WHILE WHAT(.J.) <> '(:0:)' DO
  BEGIN
    IF WHAT(.J.) <> TEXT(.I.) THEN
      STARTSWITH:= FALSE;
    I:= I + 1; J:= J + 1;
  END;
END;

FUNCTION COMMAND: COMMANDTYPE;
BEGIN
  IF STARTSWITH('DEL((:0:) ') THEN
    COMMAND:= DELETE ELSE
  IF STARTSWITH('#(:10:)(:0:) ') THEN
    COMMAND:= COPY
  ELSE
    COMMAND:= INSERT;
END;

PROCEDURE INITBUF(VAR FROM: UNIV BUFPAIR);
BEGIN
  READPAGE(FROM(.1.), LASTPAGE);
  READPAGE(FROM(.2.), LASTPAGE);
END;

PROCEDURE READBUF(VAR FROM: UNIV BUFPAIR);
BEGIN
  FROM(.1.):= FROM(.2.);
  READPAGE(FROM(.2.), LASTPAGE);
END;

PROCEDURE WRITEBUF(VAR TO_: UNIV BUFPAIR);
BEGIN
  WRITEPAGE(TO_(.1.), FALSE);
  TO_(.1.):= TO_(.2.);
END;

PROCEDURE TERMBUF(TO_: UNIV BUFPAIR);
VAR TEXT: PAGE;
BEGIN
  WRITEPAGE(TO_(.1.), FALSE);
  WRITEPAGE(TEXT, TRUE);
  WHILE NOT LASTPAGE DO
    READPAGE(TEXT, LASTPAGE);
END;

PROCEDURE READLINE;
BEGIN
  IF X > PAGELENGTH THEN
  BEGIN
    READBUF(FROM);
    X:= X - PAGELENGTH;
  END;
  LINENO:= SUCC(LINENO);
  EOF:= (FROM(.X.) = EM);
END;

PROCEDURE WRITELINE;
BEGIN
  IF Y > PAGELENGTH THEN
  BEGIN
    WRITEBUF(TO_);
    Y:= Y - PAGELENGTH;
  END;
END;

PROCEDURE READFIRST;
BEGIN
  INITBUF(FROM);
  X:= 1; Y:= 1;
  LINENO:= 0;
  READLINE;
END;

PROCEDURE WRITELAST;
BEGIN
  TO_(.Y.):= EM;
  Y:= SUCC(Y);
  WRITELINE;
  TERMBUF(TO_);
END;

PROCEDURE SKIPLINE;
BEGIN
  IF FROM(.X.) <> NL THEN
    REPEAT X:= SUCC(X)
    UNTIL FROM(.X.) = NL;
  X:= SUCC(X);
  READLINE;
END;

PROCEDURE COPYLINE;
VAR C: CHAR;
BEGIN
  REPEAT
    C:= FROM(.X.);
    X:= SUCC(X);
    TO_(.Y.):= C;
    Y:= SUCC(Y);
  UNTIL C = NL;
  READLINE;
  WRITELINE;
END;

PROCEDURE INSERTTEXT;
VAR I: INTEGER; C: CHAR;
BEGIN
  I:= 1;
  REPEAT
    C:= TEXT(.I.);
    I:= SUCC(I);
    TO_(.Y.):= C;
    Y:= SUCC(Y);
  UNTIL C = NL;
  WRITELINE;
END;

PROCEDURE DELETETEXT;
VAR FIRSTLINE, LASTLINE: INTEGER;
BEGIN
  SCANINT(FIRSTLINE);
  IF NOT OK THEN
    WARNING('LINE NUMBER(S) MISSING (:10:)') ELSE
  BEGIN
    SCANINT(LASTLINE);
    IF NOT OK THEN
    BEGIN LASTLINE:= FIRSTLINE; OK:= TRUE END;
    IF FIRSTLINE < LINENO THEN
      WARNING('LINE ALREADY PASSED(:10:)') ELSE
    IF LASTLINE < FIRSTLINE THEN
      WARNING('LINE NUMBERS ILLEGAL (:10:)') ELSE
    BEGIN
      WHILE NOT EOF & (LINENO < FIRSTLINE) DO
        COPYLINE;
      WHILE NOT EOF & (LINENO <= LASTLINE) DO
        SKIPLINE;
    END;
  END;
END;

PROCEDURE COPYTEXT;
BEGIN
  WHILE NOT EOF DO COPYLINE;
END;

PROCEDURE INITIALIZE;
BEGIN
  IDENTIFY('EDIT:(:10:)');
  OK:= (TASK = JOBTASK);
  CHECKARG;
  NLOREM:= (.NL, EM.);
  DIGIT:= (.'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'.);
  DIGITORNL:= DIGIT OR (.NL.);
END;

PROCEDURE TERMINATE;
BEGIN
  WITH PARAM(.1.) DO
  BEGIN TAG:= BOOLTYPE; BOOL:= OK END;
END;

BEGIN
  INITIALIZE;
  IF OK THEN
  BEGIN
    INITIO;
    READFIRST;
    REPEAT
      READTEXT;
      CASE COMMAND OF
        INSERT: INSERTTEXT;
        DELETE: DELETETEXT;
        COPY:   COPYTEXT
      END;
    UNTIL EOF;
    WRITELAST;
    CHECKIO;
  END;
  TERMINATE;
END.
SK);
;
AR BLOCK: UNIV PAGE);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   