        .SBTTL DATA TYPES FOR THE I/O CONTROLLERS
                                   ;"###################################
                                   ;                #  I/O DATA TYPES  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; TYPE BUFFERTYPE = ANYTYPE;
                                   ;
      $ =      0                   ; TYPE IODEVICE = (
TTY020  =      $                   ;                  TTY0,
      $ =      $ + 1               ;
DSK020  =      $                   ;                  DISK0,
      $ =      $ + 1               ;
TP9020  =      $                   ;                  TAPE90,
      $ =      $ + 1               ;
PRT020  =      $                   ;                  PRINTER0,
      $ =      $ + 1               ;
CRD020  =      $                   ;                  CARDREADER0,
      $ =      $ + 1               ;
TP9120  =      $                   ;                  TAPE91
.IODEVIC=      .INTEGER            ;                 );
                                   ;
      $ =      0                   ; TYPE IOOPERATION = (
INPU21  =      $                   ;                     INPUT,
      $ =      $ + 1               ;
OUTP21  =      $                   ;                     OUTPUT,
      $ =      $ + 1               ;
MOVE21  =      $                   ;                     MOVE,
      $ =      $ + 1               ;
CONT21  =      $                   ;                     CONTROL
.IOOPERA=      .INTEGER            ;                    );
                                   ;
      $ =      0                   ; TYPE IORESULT = (
COMP22  =      $                   ;                  COMPLETE,
      $ =      $ + 1               ;
INTE22  =      $                   ;                  INTERVENTION,
      $ =      $ + 1               ;
TRAN22  =      $                   ;                  TRANSMISSION,
      $ =      $ + 1               ;
FAIL22  =      $                   ;                  FAILURE,
      $ =      $ + 1               ;
ENDF22  =      $                   ;                  ENDFILE,
      $ =      $ + 1               ;
ENDM22  =      $                   ;                  ENDMEDIUM,
      $ =      $ + 1               ;
STAR22  =      $                   ;                  STARTMEDIUM
.IORESUL=      .INTEGER            ;                 );
                                   ;
      $ =      0                   ; TYPE IOMOVE = (
OUTE23  =      $                   ;                OUTEOF,
      $ =      $ + 1               ;
REWI23  =      $                   ;                REWIND,
      $ =      $ + 1               ;
UPSP23  =      $                   ;                UPSPACE,
      $ =      $ + 1               ;
BACK23  =      $                   ;                BACKSPACE,
      $ =      $ + 1               ;
UNLO23  =      $                   ;                UNLOAD
.IOMOVE =      .INTEGER            ;               );
                                   ;
IOPARAM =      0                   ; TYPE IOPARAM =
      $ =      IOPARAM             ;   RECORD
OPER24  =      $                   ;     OPERATION:
      $ =      $ + .IOOPERATION    ;                IOOPERATION;
STAT24  =      $                   ;     STATUS:
      $ =      $ + .IORESULT       ;             IORESULT;
MODI24  =      $                   ;     MODIFIER:
      $ =      $ + .INTEGER        ;               UNIV INTEGER;
.IOPARAM=      $ - IOPARAM         ;   END;
                                   ;
                                   ; TYPE UNITTYPE = 0..7;
                                   ;
                                   ;
        .SBTTL PROCEDURES FOR ABSENT I/O DEVICES
                                   ;"###################################
                                   ;               #  MISSING DEVICES  #
                                   ;###################################"
                                   ;
                                   ;
PARA38: .BLKB  .ADDRESS            ; PROCEDURE IOFAIL(VAR PARAM:
                                   ;                          @IOPARAM);
                                   ;
IOFA38:                            ; BEGIN
        MOV    #FAIL22,-(SP)       ;   PARAM@.STATUS := FAILURE;
        MOV    PARA38,R0           ;
        MTPD   STAT24(R0)          ;
        RTS    PC                  ; END;
                                   ;
                                   ;
DEVR39: .BLKB  .ADDRESS            ; FUNCTION DEVICEPRESENT(DEVREG:
DEV39R: .BLKB  .BOOLEAN            ;                 @INTEGER): BOOLEAN;
                                   ;
NONE39:                            ; ON NONEXISTENTMEMORYTRAP DO
        CLR    DEV39R              ;   DEVICEPRESENT := FALSE;
        RTI                        ;
                                   ;
DEVI39: MOV    #NONE39,FETRAP      ; BEGIN
        MOV    #1,DEV39R           ;   DEVICEPRESENT := TRUE;
        TST    @DEVR39             ;   IF DEVREG@ = 0 THEN ;
        MOV    #FEINT,FETRAP       ; END;
        RTS    PC                  ;
                                   ;
                                   ;
        .SBTTL TAPE (TM11) I/O DRIVER
                                   ;"###################################
                                   ;                      #  TM11TAPE  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR TM11TAPE:  "9-TRACK TAPES ONLY"
                                   ; CLASS
                                   ;
IOCO25  =      -512.               ; CONST IOCOUNT = -512;
SPAC25  =      -1.                 ;       SPACECOUNT = -1;
                                   ;
                                   ; TYPE FUNCTYPE = (
OFFL25  =      MTFOFL              ;                  OFFLINE,
READ25  =      MTFRD               ;                  READ,
WRIT25  =      MTFWR               ;                  WRITE,
WEOF25  =      MTFWFM              ;                  WRITEEOF,
FORW25  =      MTFSPF              ;                  FORWARDSPACE,
BACK25  =      MTFSPR              ;                  BACKWARDSPACE,
WGAP25  =      MTFWGP              ;                  WRITEGAP,
REWI25  =      MTFREW              ;                  REWINDTAPE
.FUNCTYP=      .INTEGER            ;                 );
                                   ;
                                   ; TYPE TAPEDENSITY = (
ST2025  =      MDS200              ;                     ST200,
ST5525  =      MDS556              ;                     ST556,
ST8025  =      MDS800              ;                     ST800,
NT8025  =      MDN800              ;                     NT800
.TAPEDEN=      .INTEGER            ;                    );
                                   ;
                                   ; TYPE TAPECOMMAND =
.TAPECOM=      .INTEGER            ;   PACKED RECORD
ERRO25  =      MTCERR              ;     ERROR: BOOLEAN;
NTDE25  =      MTCDEN * NT8025     ;     DENSITY: TAPEDENSITY;
POWE25  =      MTCPCL              ;     POWERCLEAR: BOOLEAN;
EVEN25  =      MTCPEV              ;     EVENPARITY: BOOLEAN;
UNIT25  =      MTCUS               ;     UNIT: UNITTYPE;
REDY25  =      MTCCUR              ;     READY: BOOLEAN;
INEN25  =      MTCIEN              ;     INTERRUPT: BOOLEAN;
ADDB25  =      MTCADD              ;     ADDRBITS: 0..3;
FUNC25  =      MTCFUN              ;     FUNC: FUNCTYPE;
GO25    =      MTCGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
UNIS25:                            ; VAR UNITS: ARRAY (.UNITTYPE.) OF
    $TC =      NTDE25+INEN25+GO25  ;                        TAPECOMMAND;
    $UN =      0                   ;
        .REPT  8.                  ;
        .WORD  $TC + $UN           ;
    $UN =      $UN + UNIT25        ;
        .ENDR                      ;
FTBL25: .WORD  FUNC25 * READ25     ;     FUNCTABLE: ARRAY
        .WORD  FUNC25 * WRIT25     ;        (.IOOPERATION.) OF FUNCTYPE;
MTBL25: .WORD  FUNC25 * WEOF25     ;     MOVETABLE: ARRAY (.IOMOVE.) OF
        .WORD  FUNC25 * REWI25     ;                           FUNCTYPE;
        .WORD  FUNC25 * FORW25     ;
        .WORD  FUNC25 * BACK25     ;
        .WORD  FUNC25 * OFFL25     ;
USER25: .WORD  NIL                 ;     USER: PROCESSREF;
ADDR25: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN25: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT25  =      MTS                 ;     STATUSREG:
                                   ;       PACKED RECORD
ILLE25  =      MTSILC              ;         ILLEGALCOMMAND,
ENDO25  =      MTSEOF              ;         ENDOFFILE,
CYCL25  =      MTSCRE              ;         CYCLICREDUNDANCY,
PARI25  =      MTSPAE              ;         PARITYERROR,
BUSG25  =      MTSBGL              ;         BUSGRANTLATE,
ENDT25  =      MTSEOT              ;         ENDOFTAPE,
RECO25  =      MTSRLE              ;         RECORDLENGTH,
BADT25  =      MTSBTE              ;         BADTAPE,
NONE25  =      MTSNXM              ;         NONEXISTENTMEMORY,
SELE25  =      MTSELR              ;         SELECTREMOTE,
BEGI25  =      MTSBOT              ;         BEGINNINGOFTAPE,
SVNC25  =      MTS7CH              ;         SEVENCHANNEL,
SETT25  =      MTSDWN              ;         SETTLEDOWN,
FILE25  =      MTSWRL              ;         FILEPROTECT,
REWS25  =      MTSRWS              ;         REWINDING,
TAPE25  =      MTSTUR              ;         TAPEUNITREADY: BOOLEAN;
                                   ;       END;
COMR25  =      MTC                 ;     COMMANDREG: TAPECOMMAND;
COUN25  =      MTBRC               ;     COUNTREG: INTEGER;
ADRG25  =      MTCMA               ;     ADDRREG: ADDRESS;
                                   ;
                                   ;
BUF25:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM25:  .BLKB  .ADDRESS            ;                  VAR COM: @IOPARAM;
UNIN25: .BLKB  .INTEGER            ;                  UNITNUMBER:
                                   ;                          UNITTYPE);
                                   ;
;OPER   IS     R1                  ; VAR OPER: IOOPERATION;
SKEL25: .BLKB  .TAPECOMMAND        ;     SKELETON: TAPECOMMAND;
;       AND    R2                  ;
;MOVER  IS     R1                  ;     MOVER: IOMOVE;
PREF25: .BLKB  .INTEGER            ;     PREFIX: 0..3;
                                   ;
INIO25:                            ; BEGIN
        MOV    COM25,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        ASL    R1                  ;
        MOV    R0,ADDR25           ;   ADDR := @COM@.STATUS;
        MOV    UNIN25,R2           ;   SKELETON := UNITS(.UNITNUMBER.);
        MOV    UNIS25(R2),R2       ;
                                   ;   WITH SKELETON DO
                                   ;   BEGIN
        JMP    1$(R1)              ;     IF OPER <> CONTROL THEN
1$:     BR     2$                  ;       BEGIN
        BR     3$                  ;         CASE OPER OF
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;           INPUT, OUTPUT:
                                   ;           BEGIN
        BIS    FTBL25(R1),R2       ;             FUNC :=
                                   ;                  FUNCTABLE(.OPER.);
        MOV    R2,SKEL25           ;             VIRTUAL.REALADDRESS(
        MOV    BUF25,VTLA10        ;                           BUF,
        MOV    #PREF25,PREF10      ;                           PREFIX,
        MOV    #ADRG25,REST10      ;                           ADDRREG);
        JSR    PC,REAL10           ;
        MOV    PREF25,R2           ;             ADDRBITS := PREFIX;
        ASH    #4.,R2              ;
        ADD    SKEL25,R2           ;
        MOV    #IOCO25,COUN25      ;             COUNTREG := IOCOUNT;
        BR     6$                  ;           END;
                                   ;
4$:                                ;           MOVE:
                                   ;           BEGIN
        MFPD   2(R0)               ;             MOVER := COM@.MODIFIER;
        MOV    (SP)+,R1            ;
        ASL    R1                  ;             FUNC :=
        BIS    MTBL25(R1),R2       ;                 MOVETABLE(.MOVER.);
        MOV    #SPAC25,COUN25      ;             COUNTREG := SPACECOUNT;
                                   ;           END;
                                   ;         END;
6$:     MOV    R2,COMR25           ;         COMMANDREG := SKELETON;
        JSR    PC,PREE11           ;         USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER25       ;
        RTS    PC                  ;       END ELSE
5$:                                ;       BEGIN "OPER = CONTROL"
        CLR    -(SP)               ;         COM@.STATUS := COMPLETE;
        MTPD   @ADDR25             ;
        RTS    PC                  ;       END;
                                   ;   END;
                                   ; END "OF INITIO";
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
                                   ;
INTE25:                            ; BEGIN
        MOV    USER25,R0           ;   IF USER <> NIL THEN
        BNE    1$                  ;
        RTS    PC                  ;
1$:                                ;     WITH COMMANDREG, STATUSREG DO
                                   ;     BEGIN
        MOV    R0,P12              ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        CLR    R0                  ;
        MOV    STAT25,R1           ;
        TST    COMR25              ;       IF NOT ERROR THEN
        BMI    2$                  ;
        BIT    #ENDO25,R1          ;         IF ENDOFFILE THEN
        BNE    3$                  ;           RESULT := ENDFILE ELSE
        BIT    #ENDT25,R1          ;           IF ENDOFTAPE THEN
        BNE    8$                  ;             RESULT := ENDMEDIUM
                                   ;                                ELSE
        BIT    #BEGI25,R1          ;             IF BEGINNINGOFTAPE THEN
        BNE    5$                  ;               RESULT := STARTMEDIUM
                                   ;                                ELSE
        BR     4$                  ;               RESULT := COMPLETE
2$:                                ;         ELSE "ERROR"
      $ =      RECO25              ;         IF RECORDLENGTH OR
      $ =      $ + NONE25          ;            NONEXISTENTMEMORY THEN
        BIT    #$,R1               ;
        BNE    6$                  ;           RESULT := FAILURE ELSE
        BIT    #ILLE25,R1          ;           IF ILLEGALCOMMAND THEN
        BNE    7$                  ;             RESULT := INTERVENTION
                                   ;                                ELSE
      $ =      CYCL25              ;             IF CYCLICREDUNDANCY OR
      $ =      $ + PARI25          ;                PARITYERROR OR
      $ =      $ + BADT25          ;                BADTAPE OR
      $ =      $ + BUSG25          ;                BUSGRANTLATE THEN
        BIT    #$,R1               ;
        BNE    9$                  ;               RESULT :=
                                   ;                   TRANSMISSION ELSE
        BIT    #ENDO25,R1          ;               IF ENDOFFILE THEN
        BNE    3$                  ;                 RESULT := ENDFILE
                                   ;                                ELSE
        BR     8$                  ;                 RESULT :=
                                   ;                          ENDMEDIUM;
5$:     INC    R0                  ;
8$:     INC    R0                  ;
3$:     INC    R0                  ;
6$:     INC    R0                  ;
9$:     INC    R0                  ;
7$:     INC    R0                  ;
4$:     MOV    R0,-(SP)            ;
        MOV    USER25,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR25             ;       ADDR@ := RESULT;
        CLR    USER25              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ;   END;
                                   ; END "OF INTERRUPT";
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
                                   ; VAR I: UNITTYPE;
                                   ;
INIZ25:                            ; BEGIN
; ALL OF THE INITIALIZATIONS SHOWN ;   USER := NIL;
; HERE HAVE BEEN PERFORMED BY PRE- ;   FOR I := 0 TO 7 DO
; CEDING CONSTANT DECLARATIONS AT  ;     WITH UNITS(.I.) DO
; THE LABELS:                      ;     BEGIN
;                                  ;       ERROR := FALSE;
;       USER25,                    ;       DENSITY := NT800;
;       UNIS25,                    ;       POWERCLEAR := FALSE;
;       FTBL25, AND                ;       EVENPARITY := FALSE;
;       MTBL25.                    ;       UNIT := 2;
;                                  ;       READY := FALSE;
;                                  ;       INTERRUPT := TRUE;
;                                  ;       ADDRBITS := 0;
;                                  ;       FUNC := OFFLINE;
;                                  ;       GO := TRUE;
;                                  ;     END;
;                                  ;   FUNCTABLE(.INPUT.) := READ;
;                                  ;   FUNCTABLE(.OUTPUT.) := WRITE;
;                                  ;   MOVETABLE(.OUTEOF.) := WRITEEOF;
;                                  ;   MOVETABLE(.REWIND.) :=
;                                  ;                         REWINDTAPE;
;                                  ;   MOVETABLE(.UPSPACE.) :=
;                                  ;                       FORWARDSPACE;
;                                  ;   MOVETABLE(.BACKSPACE.) :=
;                                  ;                      BACKWARDSPACE;
;                                  ;   MOVETABLE(.UNLOAD.) := OFFLINE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT25:                            ; BEGIN
        MOV    #STAT25,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN25       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ25           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF TM11TAPE";
                                   ;
                                   ;
        .SBTTL DISK (RK11) I/O DRIVER
                                   ;"###################################
                                   ;                      #  RK11DISK  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR RK11DISK:
                                   ; CLASS
                                   ;
IOCO27  =      -256.               ; CONST IOCOUNT = -256;
                                   ;
                                   ; TYPE FUNCTYPE = (
CONT27  =      RCFCRE              ;                  CONTROLRESET,
WRIT27  =      RCFWR               ;                  WRITE,
READ27  =      RCFRD               ;                  READ,
WRCH27  =      RCFWRC              ;                  WRITECHECK,
SEEK27  =      RCFSK               ;                  SEEK,
RDCH27  =      RCFRDC              ;                  READCHECK,
DRVR27  =      RCFDRE              ;                  DRIVERESET,
WRLK27  =      RCFWRL              ;                  WRITELOCK
                                   ;                 );
                                   ;
      $ =      0                   ; TYPE DISKCONTROL = (
LOAD27  =      $                   ;                     LOAD
                                   ;                    );
                                   ;
                                   ; TYPE DISKCOMMAND =
                                   ;   PACKED RECORD
ERRO27  =      RCSERR              ;     ERROR,
HARD27  =      RCSHE               ;     HARDERROR,
SEAR27  =      RCSSCP              ;     SEARCHCOMPLETE,
INHI27  =      RCSIBA              ;     INHIBITINCREMENT,
FORM27  =      RCSFMT              ;     FORMAT,
STOP27  =      RCSSSE              ;     STOPONSOFTERROR,
CONR27  =      RCSRDY              ;     CONTROLREADY,
INEN27  =      RCSIDE              ;     INTERRUPT: BOOLEAN;
ADDB27  =      RCSMEX              ;     ADDRBITS: 0..3;
FUNC27  =      RCSFUN              ;     FUNC: FUNCTYPE;
GO27    =      RCSGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
                                   ; TYPE DISKADDRESS =
                                   ;   PACKED RECORD
DRIV27  =      RDADRS              ;     DRIVE: UNITTYPE;
CYLI27  =      RDACYL              ;     CYLINDER: 0..199;
SURF27  =      RDASUR              ;     SURFACE: 0..1;
SECT27  =      RDASC               ;     SECTOR: 0..11;
                                   ;   END;
                                   ;
FTBL27:                            ; VAR FUNCTABLE: ARRAY
      $ =      INEN27 + GO27       ;        (.IOOPERATION.) OF FUNCTYPE;
        .WORD  FUNC27 * READ27 + $ ;
        .WORD  FUNC27 * WRIT27 + $ ;
USER27: .WORD  NIL                 ;     USER: PROCESSREF;
ADDR27: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN27: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
ERRR27  =      RKER                ;     ERRORREG:
                                   ;       PACKED RECORD
DRVE27  =      RERDRE              ;         DRIVEERROR,
OVER27  =      REROVR              ;         OVERRUN,
WRVI27  =      RERWLO              ;         WRITEVIOLATION,
SKER27  =      RERSKE              ;         SEEKERROR,
PROG27  =      RERPGE              ;         PROGRAMERROR,
NONE27  =      RERNXM              ;         NONEXISTENTMEMORY,
DATA27  =      RERDLT              ;         DATALATE,
TIMI27  =      RERTE               ;         TIMINGERROR,
NXDI27  =      RERNXD              ;         NONEXISTENTDISK,
NXCY27  =      RERNXC              ;         NONEXISTENTCYLINDER,
NXSE27  =      RERNXS              ;         NONEXISTENTSECTOR,
CHEC27  =      RERCSE              ;         CHECKSUMERROR,
WRCE27  =      RERWCE              ;         WRITECHECKERROR: BOOLEAN;
                                   ;       END;
COMM27  =      RKCS                ;     COMMANDREG: DISKCOMMAND;
COUN27  =      RKWC                ;     COUNTREG: INTEGER;
ADRG27  =      RKBA                ;     ADDRREG: ADDRESS;
SRRG27  =      RKDA                ;     SEARCHREG: DISKADDRESS;
                                   ;
                                   ;
BUF27:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM27:  .BLKB  .ADDRESS            ;                  VAR COM: @IOPARAM;
UNIN27: .BLKB  .INTEGER            ;                  UNITNUMBER:
                                   ;                          UNITTYPE);
                                   ;
;OPER   IS     R1                  ; VAR OPER: IOOPERATION;
IOAR27: .BLKB  .INTEGER            ;     IOARG: UNIV INTEGER;
;BLOCK  IS     R0, R1              ;     BLOCK: 0..4799;
;DISKADDR IS   R0                  ;     DISKADDR: DISKADDRESS;
DISK27: .BLKB  .INTEGER            ;     DISKFUNC: DISKCOMMAND;
PREF27: .BLKB  .INTEGER            ;     PREFIX: 0..3;
                                   ;
INIO27:                            ; BEGIN
        MOV    COM27,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        MOV    R0,ADDR27           ;   ADDR := @COM@.STATUS;
        ADD    #2,R0               ;   IOARG := COM@.MODIFIER;
        MFPD   (R0)                ;
        MOV    (SP)+,IOAR27        ;
                                   ;   WITH DISKADDR, DISKFUNC DO
        ASL    R1                  ;   CASE OPER OF
        JMP    1$(R1)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;     INPUT, OUTPUT:
                                   ;     BEGIN
        MOV    FTBL27(R1),DISK27   ;       DISKFUNC :=
                                   ;                  FUNCTABLE(.OPER.);
        MOV    BUF27,VTLA10        ;       VIRTUAL.REALADDRESS(BUF,
        MOV    #PREF27,PREF10      ;                           PREFIX,
        MOV    #ADRG27,REST10      ;                           ADDRREG);
        JSR    PC,REAL10           ;
        MOV    PREF27,R0           ;       ADDRBITS := PREFIX;
        ASH    #4.,R0              ;
        ADD    R0,DISK27           ;
        MOV    #IOCO27,COUN27      ;       COUNTREG := IOCOUNT;
        MOV    IOAR27,R1           ;       BLOCK := IOARG;
        CLR    R0                  ;       SECTOR := BLOCK MOD 12;
        DIV    #12.,R0             ;       BLOCK := BLOCK DIV 12;
                                   ;       SURFACE := BLOCK MOD 2;
        MOV    UNIN27,R2           ;       DRIVE := UNITNUMBER;
        SWAB   R2                  ;
        BIS    R2,R0               ;
        ASH    #4,R0               ;       CYLINDER := BLOCK DIV 2;
        BIS    R1,R0               ;
        MOV    R0,SRRG27           ;       SEARCHREG := DISKADDR
	BIS    UNITNO,SRRG27	   ;<01>			   + UNIT;
        MOV    DISK27,COMM27       ;       COMMANDREG := DISKFUNC;
        JSR    PC,PREE11           ;       USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER27       ;
        RTS    PC                  ;     END;
                                   ;
4$:                                ;     MOVE:
        CLR    -(SP)               ;     COM@.STATUS := COMPLETE;
        MTPD   @ADDR27             ;
        RTS    PC                  ;
                                   ;
5$:                                ;     CONTROL:
        MOV    IOAR27,$SDA0        ;     KERNEL.INITIALIZE(IOARG);
        JMP    $RVM0               ;
                                   ;   END;
                                   ; END "OF INITIO";
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
                                   ;
INTE27:                            ; BEGIN
        MOV    USER27,R0           ;   IF USER <> NIL THEN
        BNE    1$                  ;
        RTS    PC                  ;
                                   ;     WITH COMMANDREG, ERRORREG DO
1$:                                ;     BEGIN
        MOV    R0,P12              ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        CLR    R0                  ;
        BIT    #HARD27,COMM27      ;       IF NOT HARDERROR THEN
        BNE    2$                  ;
        TST    COMM27              ;         IF ERROR THEN
        BMI    3$                  ;           RESULT := TRANSMISSION
        BR     4$                  ;           ELSE RESULT := COMPLETE
2$:                                ;         ELSE "HARDERROR"
      $ =      OVER27              ;         IF OVERRUN OR
      $ =      $ + PROG27          ;            PROGRAMERROR OR
      $ =      $ + NONE27          ;            NONEXISTENTMEMORY OR
      $ =      $ + NXDI27          ;            NONEXISTENTDISK OR
      $ =      $ + NXCY27          ;            NONEXISTENTCYLINDER OR
      $ =      $ + NXSE27          ;            NONEXISTENTSECTOR THEN
        BIT    #$,ERRR27           ;
        BNE    5$                  ;           RESULT := FAILURE ELSE
      $ =      DRVE27              ;           IF DRIVEERROR OR
      $ =      $ + WRVI27          ;              WRITEVIOLATION THEN
        BIT    #$,ERRR27           ;             RESULT := INTERVENTION
        BNE    6$                  ;                                ELSE
                                   ;             IF SEEKERROR OR
                                   ;                TIMINGERROR OR
                                   ;                DATALATE THEN
        BR     3$                  ;               RESULT :=
                                   ;                       TRANSMISSION;
5$:     INC    R0                  ;       IF RESULT <> COMPLETE THEN
3$:     INC    R0                  ;         BEGIN
6$:     INC    R0                  ;           FUNC := CONTROLRESET;
      $ =      FUNC27*CONT27+GO27  ;           INTERRUPT := FALSE;
        MOV    #$,COMM27           ;           GO := TRUE;
7$:     TSTB   COMM27              ;           REPEAT UNTIL
        BGE    7$                  ;                       CONTROLREADY;
                                   ;         END;
4$:     MOV    R0,-(SP)            ;
        MOV    USER27,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR27             ;       ADDR@ := RESULT;
        CLR    USER27              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END "OF INTERRUPT";
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ27:                            ; BEGIN
; ALL OF THE INITIALIZATIONS SHOWN ;   USER := NIL;
; HERE HAVE BEEN PERFORMED BY PRE- ;   WITH FUNCTABLE(.INPUT.) DO
; CEDING CONSTANT DECLARATIONS AT  ;   BEGIN
; THE LABELS:                      ;     INTERRUPT := TRUE;
;                                  ;     FUNC := READ;
;       USER27, AND                ;     GO := TRUE;
;       FTBL27.                    ;     INHIBITINCREMENT := FALSE;
;                                  ;     FORMAT := FALSE;
;                                  ;     STOPONSOFTERROR := FALSE;
;                                  ;     ADDRBITS := 0;
;                                  ;   END;
;                                  ;   WITH FUNCTABLE(.OUTPUT.) DO
;                                  ;   BEGIN
;                                  ;     INTERRUPT := TRUE;
;                                  ;     FUNC := WRITE;
;                                  ;     GO := TRUE;
;                                  ;     INHIBITINCREMENT := FALSE;
;                                  ;     FORMAT := FALSE;
;                                  ;     STOPONSOFTERROR := FALSE;
;                                  ;     ADDRBITS := 0;
;                                  ;   END;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT27:                            ; BEGIN
        MOV    #ERRR27,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                          ERRORREG);
        MOV    DEV39R,CONN27       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ27           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF RK11DISK";
                                   ;
                                   ;
        .SBTTL TERMINAL (LT33) I/O DRIVER
                                   ;"###################################
                                   ;                  #  LT33TERMINAL  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR LT33TERMINAL:
                                   ; CLASS
                                   ;
BELC28  =      7.                  ; CONST BELCHAR = '(:7:)';
LFCH28  =      10.                 ;       LFCHAR = '(:10:)';
CRCH28  =      13.                 ;       CRCHAR = '(:13:)';
                                   ;
      $ =      0                   ; TYPE TERMINALSTATE = (
PASS28  =      $                   ;                       PASSIVE,
      $ =      $ + 1               ;
READ28  =      $                   ;                       READING,
      $ =      $ + 1               ;
WRIT28  =      $                   ;                       WRITING
                                   ;                      );
                                   ;
      $ =      0                   ; TYPE TERMCONTROL = (
WAIT28  =      $                   ;                     WAITFORBELL
                                   ;                    );
                                   ;
                                   ; TYPE STATUSTYPE =
                                   ;   PACKED RECORD
BUSY28  =      TSRBSY              ;     BUSY,
DONE28  =      TSRRDY              ;     DONE,
INEN28  =      TSRIDE              ;     INTERRUPT,
GO28    =      TSRGO               ;     GO: BOOLEAN;
                                   ;   END;
                                   ;
                                   ; VAR ENTRY
STAT28: .WORD  PASS28              ;     STATE: TERMINALSTATE;
BELL28: .BLKB  .SIGNAL             ; VAR BELL: SIGNAL;
CHAR28: .BLKB  .ADDRESS            ;     CHARADDR: @BUFFERTYPE;
USER28: .BLKB  .ADDRESS            ;     USER: PROCESSREF;
OUTL28: .WORD  0                   ;     OUTLF: BOOLEAN;
ECHO28: .WORD  0                   ;     ECHO: BOOLEAN;
INCH28: .BLKB  .CHAR               ;     INCHAR: CHAR;
CONN28: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
                                   ;     READREGS:
                                   ;         PACKED RECORD
RDST28  =      RCSR                ;         READSTATUS: STATUSTYPE;
RDBF28  =      RBUF                ;         READBUF: CHAR;
                                   ;       END;
                                   ;     WRITEREGS:
                                   ;       PACKED RECORD
WRST28  =      XCSR                ;         WRITESTATUS: STATUSTYPE;
WRBF28  =      XBUF                ;         WRITEBUF: CHAR;
                                   ;       END;
                                   ;
                                   ;
CH28:   .BLKB  .CHAR               ; PROCEDURE WRITECHAR(CH: CHAR);
                                   ;
WRCH28:                            ; BEGIN
        MOV    #WRIT28,STAT28      ;   STATE := WRITING;
        CMP    #LFCH28,CH28        ;   IF CH = LFCHAR THEN
        BNE    1$                  ;     BEGIN
        MOV    #1,OUTL28           ;       OUTLF := TRUE;
        MOV    #CRCH28,WRBF28      ;       WRITEBUF := CRCHAR;
        BR     2$                  ;     END ELSE
1$:     MOV    CH28,WRBF28         ;     WRITEBUF := CH;
2$:     BIS    #INEN28,WRST28      ;   WRITEREGS.WRITESTATUS.INTERRUPT
                                   ;                            := TRUE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE READINTERRUPT;
                                   ;
RINT28:                            ; BEGIN
        MOV    RDBF28,INCH28       ;   INCHAR := READBUF;
        BIC    #ASCII8,INCH28      ;
        CMP    #BELC28,INCH28      ;   IF INCHAR = BELCHAR THEN
        BNE    1$                  ;
        MOV    #BELL28,SIG26T      ;     BELL.SEND ELSE
     $$ =      SEND26              ;
        BLTICK                     ;
        JSR    PC,$$               ;
        BR     2$                  ;
1$:     CMP    #READ28,STAT28      ;     IF STATE = READING THEN
        BNE    2$                  ;       BEGIN
        CMP    #CRCH28,INCH28      ;         IF INCHAR = CRCHAR THEN
        BNE    3$                  ;           INCHAR := LFCHAR;
        MOV    #LFCH28,INCH28      ;
3$:     MOV    #1,ECHO28           ;         ECHO := TRUE;
        MOV    INCH28,CH28         ;         WRITECHAR(INCHAR);
        JSR    PC,WRCH28           ;       END;
2$:     INC    RDST28              ;   READREGS.READSTATUS.GO := TRUE;
        RTS    PC                  ; END;
                                   ;
                                   ;
                                   ; PROCEDURE WRITEINTERRUPT;
                                   ;
WINT28:                            ; BEGIN
        CMP    #WRIT28,STAT28      ;   IF STATE = WRITING THEN
        BNE    1$                  ;     BEGIN
        TST    OUTL28              ;       IF OUTLF THEN
        BEQ    2$                  ;         BEGIN
        CLR    OUTL28              ;           OUTLF := FALSE;
        MOV    #LFCH28,WRBF28      ;           WRITEBUF := LFCHAR;
        BR     1$                  ;         END ELSE
2$:                                ;         BEGIN
        MOV    USER28,P12          ;           READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        MOV    #PASS28,STAT28      ;           STATE := PASSIVE;
        TST    ECHO28              ;           IF ECHO THEN
        BEQ    3$                  ;             BEGIN
        CLR    ECHO28              ;               ECHO := FALSE;
        MOV    USER28,P10          ;               VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        MOV    INCH28,-(SP)        ;               CHARADDR@ := INCHAR;
        BIS    #PSPMDU,PSW         ;
        MTPD   @CHAR28             ;             END;
3$:     JSR    PC,ENDI12           ;           READY.ENDIO;
                                   ;         END;
                                   ;     END;
1$:     RTS    PC                  ; END;
                                   ;
                                   ;
BUF28:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF:
                                   ;                        @BUFFERTYPE;
COM28:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
OPER28: .BLKB  .INTEGER            ; VAR OPER: IOOPERATION;
                                   ;
INIO28:                            ; BEGIN
        MOV    COM28,R0            ;   OPER := COM@.OPERATION;
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        MOV    R1,OPER28           ;
        CLR    -(SP)               ;   COM@.STATUS := COMPLETE;
        MTPD   (R0)                ;
        ASL    R1                  ;   CASE OPER OF
        JMP    1$(R1)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
2$: 3$:                            ;     INPUT, OUTPUT:
                                   ;     BEGIN
        JSR    PC,PREE11           ;       USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER28       ;
        TST    OPER28              ;       IF OPER = INPUT THEN
        BNE    6$                  ;         BEGIN
        MOV    BUF28,CHAR28        ;           CHARADDR := BUF;
        MOV    #READ28,STAT28      ;           STATE := READING;
        RTS    PC                  ;         END ELSE
6$:     MFPD   @BUF28              ;         WRITECHAR(BUF@);
        MOV    (SP)+,CH28          ;
        JSR    PC,WRCH28           ;
        RTS    PC                  ;     END;
5$:                                ;     CONTROL:
        MOV    #BELL28,SIG26T      ;       BELL.AWAIT;
        JSR    PC,AWAI26           ;
4$:                                ;     MOVE: ;
        RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
CHR28:  .BLKB  .CHAR               ; PROCEDURE KERNELWRITE(CHR: CHAR);
                                   ;
KERN28:                            ; BEGIN
                                   ; WITH WRITEREGS, WRITESTATUS DO
                                   ;   BEGIN
1$:     TSTB   WRST28              ;     REPEAT UNTIL DONE;
        BGE    1$                  ;
        MOV    #PASS28,STAT28      ;     STATE := PASSIVE;
        MOV    CHR28,WRBF28        ;     WRITEBUF := CHR;
2$:     TSTB   WRST28              ;     REPEAT UNTIL DONE;
        BGE    2$                  ;
        CLR    OUTL28              ;     OUTLF := FALSE;
        CLR    ECHO28              ;     ECHO := FALSE;
        RTS    PC                  ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ28:                            ; BEGIN
        MOV    #BELL28,SIG26T      ;   BELL.INITIALIZE;
        JSR    PC,INIT26           ;
                                   ;   STATE := PASSIVE;
                                   ;   OUTLF := FALSE;
                                   ;   ECHO := FALSE;
                                   ;   WITH READREGS, READSTATUS DO
                                   ;   BEGIN
      $ =      INEN28 + GO28       ;     INTERRUPT := TRUE;
        MOV    #$,RDST28           ;     GO := TRUE;
                                   ;   END;
                                   ;   WRITEREGS.WRITESTATUS.INTERRUPT
                                   ;                           := FALSE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT28:                            ; BEGIN
        MOV    #RDST28,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;               READREGS.READSTATUS);
        MOV    DEV39R,CONN28       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        MOV    #WRST28,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;             WRITEREGS.WRITESTATUS);
        MOV    DEV39R,CONN28       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ28           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF LT33TERMINAL";
                                   ;
                                   ;
        .SBTTL LINE PRINTER (LPXX) I/O DRIVER
                                   ;"###################################
                                   ;                   #  LPXXPRINTER  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR LPXXPRINTER:
                                   ; CLASS
                                   ;
                                   ; TYPE LINE = ARRAY (.1..124.) OF
                                   ;                               CHAR;
USER29: .WORD  NIL                 ; VAR USER: PROCESSREF;
ADDR29: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
CONN29: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT29  =      LPS                 ;     STATUSREG:
                                   ;       PACKED RECORD
ERRO29  =      LPSERR              ;         ERROR,
READ29  =      LPSRDY              ;         READY,
INEN29  =      LPSIDE              ;         INTERRUPT: BOOLEAN;
                                   ;       END;
BUFF29  =      LPB                 ;     BUFFER: CHAR;
                                   ;
                                   ;
BUF29:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(BUF: @LINE;
COM29:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
;CURSOR IS     R0                  ; VAR CURSOR: @LINE;
;I      IS     R0                  ;     I: INTEGER;
                                   ;
INIO29: MOV    COM29,R0            ; BEGIN
        MFPD   (R0)+               ;
        MOV    (SP)+,R1            ;
        TST    STAT29              ;   IF STATUSREG.ERROR THEN "OFFLINE"
        BGE    1$                  ;     COM@.STATUS := INTERVENTION
        MOV    #INTE22,R2          ;                                ELSE
        BR     2$                  ;
1$:     DEC    R1                  ;     IF COM@.OPERATION <> OUTPUT
        BEQ    3$                  ;                                THEN
        CLR    R2                  ;       COM@.STATUS := COMPLETE ELSE
2$:     MOV    R2,-(SP)            ;
        MTPD   (R0)                ;
        RTS    PC                  ;
3$:                                ;       BEGIN
        MOV    R0,ADDR29           ;         ADDR := @COM@.STATUS;
        MOV    BUF29,R0            ;         CURSOR := BUF;
                                   ;         I := 1;
4$:     MFPD   (R0)+               ;         REPEAT
        MOV    (SP)+,R1            ;           STATUSREG.INTERRUPT:=
        BIS    #INEN29,STAT29      ;             TRUE;
        MOV    #8.,R2
5$:     SOB    R2,5$
        MOVB   R1,BUFF29           ;           BUFFER:= CURSOR@.(.I.);
        MOV    #8.,R2
6$:     SOB    R2,6$
        TSTB   STAT29              ;
        BGE    9$                  ;
        SWAB   R1                  ;
        BIS    #INEN29,STAT29      ;
        MOV    #8.,R2
7$:     SOB    R2,7$
        MOVB   R1,BUFF29           ;           I:= I + 1;
        MOV    #8.,R2
8$:     SOB    R2,8$
        TSTB   STAT29              ;
        BMI    4$                  ;         UNTIL NOT STATUSREG.READY;
9$:
        JSR    PC,PREE11           ;         USER := RUNNING.PREEMPTED;
        MOV    PRE11R,USER29       ;
        RTS    PC                  ;       END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
INTE29:                            ; BEGIN
        TST    USER29              ;   IF USER <> NIL THEN
        BNE    1$                  ;
        RTS    PC                  ;     BEGIN
1$:     MOV    USER29,P12          ;       READY.ENTER(USER);
        JSR    PC,ENTE12           ;
        MOV    USER29,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        CLR    -(SP)               ;
        TST    STAT29              ;       IF STATUSREG.ERROR THEN
        BGE    2$                  ;
        INC    (SP)                ;         ADDR@ := INTERVENTION ELSE
2$:     BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR29             ;         ADDR@ := COMPLETE;
        CLR    USER29              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ29:                            ; BEGIN
; DONE AT LABEL "USER29".          ;   USER := NIL;
;                                  ;   STATUSREG.INTERRUPT := FALSE;
        RTS    PC                  ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT29:                            ; BEGIN
        MOV    #STAT29,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN29       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ29           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF LPXXPRINTER";
                                   ;
                                   ;
        .SBTTL CARDREADER (CD11-A) I/O DRIVER
                                   ;"###################################
                                   ;               #  CD11ACARDREADER  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; VAR CD11ACARDREADER:
                                   ; CLASS
                                   ;
IOCO30  =      -80.                ; CONST IOCOUNT = -80;
SUBC30  =      26.                 ;       SUBCHAR = '(:26:)';
                                   ;
                                   ; TYPE CHARCODE = -128..127;
                                   ; TYPE CARD = ARRAY (.1..80.) OF
                                   ;                               CHAR;
USER30: .WORD  NIL                 ; VAR USER: PROCESSREF;
ADDR30: .BLKB  .ADDRESS            ;     ADDR: @IORESULT;
IMAG30: .BLKB  .ADDRESS            ;     IMAGE: @CARD;
                                   ;     I: INTEGER;
BUFF30: .BLKB  80.                 ;     BUFFER: ARRAY (.1..80.) OF
                                   ;                           CHARCODE;
TRAN30  =      TTBL30 + 128.       ;     TRANSLATE: ARRAY (.CHARCODE.)
                                   ;                            OF CHAR;
CONN30: .BLKB  .BOOLEAN            ; VAR ENTRY
                                   ;     CONNECTED: BOOLEAN;
                                   ; "HARDWARE"
STAT30  =      CDST                ;     STATUSREG
                                   ;       PACKED RECORD
ERRO30  =      CDSERR              ;         ERROR,
RDCH30  =      CDSRDC              ;         READERCHECK,
ENDO30  =      CDSEOF              ;         ENDOFFILE,
OFFL30  =      CDSOFL              ;         OFFLINE,
DTER30  =      CDSDER              ;         DATAERROR,
DTLT30  =      CDSDTL              ;         DATALATE,
NONE30  =      CDSNXM              ;         NONEXISTENTMEMORY,
POWE30  =      CDSPCL              ;         POWERCLEAR,
READ30  =      CDSRDY              ;         READY,
INEN30  =      CDSIDE              ;         INTERRUPT: BOOLEAN;
ADDB30  =      CDSMEX              ;         ADDRBITS: 0..3;
TRNS30  =      CDSOLT              ;         TRANSITION,
HOPP30  =      CDSHPC              ;         HOPPERCHECK,
DTPK30  =      CDSDPK              ;         DATAPACKING,
GO30    =      CDSGO               ;         GO: BOOLEAN;
                                   ;       END;
COUN30  =      CDCC                ;     COUNTREG: INTEGER;
ADRG30  =      CDBA                ;     ADDRREG: ADDRESS;
                                   ;
                                   ;
BUF30:  .BLKB  .ADDRESS            ; PROCEDURE INITIO(VAR BUF: @CARD;
COM30:  .BLKB  .ADDRESS            ;                  VAR COM:
                                   ;                          @IOPARAM);
                                   ;
INIO30: MOV    COM30,R0            ; BEGIN
        MFPD   (R0)+               ;   WITH STATUSREG DO
        MOV    (SP)+,R1            ;   BEGIN
        BIT    #OFFL30,STAT30      ;     IF OFFLINE THEN
        BEQ    1$                  ;
        MOV    #INTE22,-(SP)       ;       COM@.STATUS := INTERVENTION
        BR     2$                  ;                                ELSE
1$:     TST    R1                  ;       IF COM@.OPERATION <> INPUT
                                   ;                                THEN
        BEQ    3$                  ;         COM@.STATUS := COMPLETE
        CLR    -(SP)               ;                                ELSE
2$:     MTPD   (R0)                ;
        RTS    PC                  ;         BEGIN
3$:     MOV    R0,ADDR30           ;           ADDR := @COM@.STATUS;
        MOV    BUF30,IMAG30        ;           IMAGE := BUF;
        MOV    #BUFF30,ADRG30      ;           ADDRREG := @BUFFER;
        MOV    #IOCO30,COUN30      ;           COUNTREG := IOCOUNT;
      $ =      INEN30              ;           INTERRUPT := TRUE;
        BIS    #<$+GO30>,STAT30    ;           GO := TRUE;
        JSR    PC,PREE11           ;           USER :=
        MOV    PRE11R,USER30       ;                  RUNNING.PREEMPTED;
        RTS    PC                  ;         END;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INTERRUPT;
                                   ;
;RESULT IS     R0                  ; VAR RESULT: IORESULT;
;I      IS     R0                  ;     I: INTEGER;
                                   ;
INTE30: MOV    USER30,R0           ; BEGIN
        BNE    1$                  ;   IF USER <> NIL THEN
        RTS    PC                  ;     WITH STATUSREG DO
1$:     MOV    R0,P12              ;     BEGIN
        JSR    PC,ENTE12           ;       READY.ENTER(USER);
        MOV    USER30,P10          ;       VIRTUAL.GETMAP(USER);
        JSR    PC,GETM10           ;
        CLR    R0                  ;       RESULT := COMPLETE;
        MOV    STAT30,R1           ;       IF ERROR THEN
        BGE    2$                  ;
        BIT    #OFFL30,R1          ;         IF OFFLINE AND
        BEQ    8$                  ;
        BIT    #HOPP30,R1          ;            NOT HOPPERCHECK THEN
        BEQ    3$                  ;           RESULT := INTERVENTION
                                   ;                                ELSE
8$:     BIT    #DTLT30,R1          ;           IF DATALATE THEN
        BNE    7$                  ;             RESULT := FAILURE ELSE
        BIT    #DTER30,R1          ;             IF DATAERROR THEN
        BNE    6$                  ;               RESULT :=
        BR     2$                  ;                       TRANSMISSION;
7$:     INC    R0                  ;
6$:     INC    R0                  ;
3$:     INC    R0                  ;
2$:     MOV    R0,-(SP)            ;       ADDR@ := RESULT;
        BIS    #PSPMDU,PSW         ;
        MTPD   @ADDR30             ;
        TST    R0                  ;       IF (RESULT = COMPLETE) OR
        BEQ    9$                  ;
        CMP    #TRAN22,R0          ;          (RESULT = TRANSMISSION)
        BNE    4$                  ;                                THEN
9$:     MOV    #40.,R0             ;         FOR I := 1 TO 80 DO
        MOV    IMAG30,R1           ;
        MOV    #BUFF30,R2          ;
5$:     MOVB   (R2)+,R3            ;       IMAGE@(.I.) :=
        MOVB   TRAN30(R3),R4       ;           TRANSLATE(.BUFFER(.I.).);
        MOVB   (R2)+,R3            ;
        MOVB   TRAN30(R3),R3       ;
        SWAB   R3                  ;
        BIS    R4,R3               ;
        MOV    R3,-(SP)            ;
        MTPD   (R1)+               ;
        SOB    R0,5$               ;
4$:     CLR    USER30              ;       USER := NIL;
        JSR    PC,ENDI12           ;       READY.ENDIO;
        RTS    PC                  ;     END;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE INITIALIZE;
                                   ;
INIZ30:                            ; BEGIN
; DONE AT LABEL "USER30".          ;   USER := NIL;
;                                  ;   WITH STATUSREG DO
;                                  ;   BEGIN
        BIS    #POWE30,STAT30      ;     POWERCLEAR := TRUE;
      $ =      0                   ;     INTERRUPT := FALSE;
                                   ;     ADDRBITS := 0;
      $ =      $ + DTPK30          ;     DATAPACKING := TRUE;
                                   ;     GO := FALSE;
        BIS    #$,STAT30           ;   END;
        RTS    PC                  ;
TTBL30:                            ;
        .ASCII /&ABCDEFGH/         ;   TRANSLATE(.-128.) := '&';
                                   ;   TRANSLATE(.-127.) := 'A';
                                   ;   TRANSLATE(.-126.) := 'B';
                                   ;   TRANSLATE(.-125.) := 'C';
                                   ;   TRANSLATE(.-124.) := 'D';
                                   ;   TRANSLATE(.-123.) := 'E';
                                   ;   TRANSLATE(.-122.) := 'F';
                                   ;   TRANSLATE(.-121.) := 'G';
                                   ;   TRANSLATE(.-120.) := 'H';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.-119.) := SUBCHAR;
                                   ;   TRANSLATE(.-118.) := SUBCHAR;
        .ASCII /.<(+!I/            ;   TRANSLATE(.-117.) := '.';
                                   ;   TRANSLATE(.-116.) := '<';
                                   ;   TRANSLATE(.-115.) := '(';
                                   ;   TRANSLATE(.-114.) := '+';
                                   ;   TRANSLATE(.-113.) := '!';
                                   ;   TRANSLATE(.-112.) := 'I';
        .REPT  55.                 ;   FOR I := -111 TO -1 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII / 12345678/         ;   TRANSLATE(.0.) := ' ';
                                   ;   TRANSLATE(.1.) := '1';
                                   ;   TRANSLATE(.2.) := '2';
                                   ;   TRANSLATE(.3.) := '3';
                                   ;   TRANSLATE(.4.) := '4';
                                   ;   TRANSLATE(.5.) := '5';
                                   ;   TRANSLATE(.6.) := '6';
                                   ;   TRANSLATE(.7.) := '7';
                                   ;   TRANSLATE(.8.) := '8';
        .ASCII <SUBC30>            ;   TRANSLATE(.9.) := SUBCHAR;
        .ASCII /:#@'="9/           ;   TRANSLATE(.10.) := ':';
                                   ;   TRANSLATE(.11.) := '#';
                                   ;   TRANSLATE(.12.) := '@';
                                   ;   TRANSLATE(.13.) := '''';
                                   ;   TRANSLATE(.14.) := '=';
                                   ;   TRANSLATE(.15.) := '"';
                                   ;   TRANSLATE(.16.) := '9';
        .REPT  7                   ;   FOR I := 17 TO 31 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII ;0/STUVWXY;         ;   TRANSLATE(.32.) := '0';
                                   ;   TRANSLATE(.33.) := '/';
                                   ;   TRANSLATE(.34.) := 'S';
                                   ;   TRANSLATE(.35.) := 'T';
                                   ;   TRANSLATE(.36.) := 'U';
                                   ;   TRANSLATE(.37.) := 'V';
                                   ;   TRANSLATE(.38.) := 'W';
                                   ;   TRANSLATE(.39.) := 'X';
                                   ;   TRANSLATE(.40.) := 'Y';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.41.) := SUBCHAR;
                                   ;   TRANSLATE(.42.) := SUBCHAR;
        .ASCII /,%_>?Z/            ;   TRANSLATE(.43.) := ',';
                                   ;   TRANSLATE(.44.) := '%';
                                   ;   TRANSLATE(.45.) := '_';
                                   ;   TRANSLATE(.46.) := '>';
                                   ;   TRANSLATE(.47.) := '?';
                                   ;   TRANSLATE(.48.) := 'Z';
        .REPT  7                   ;   FOR I := 49 TO 63 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
        .ASCII /-JKLMNOPQ/         ;   TRANSLATE(.64.) := '-';
                                   ;   TRANSLATE(.65.) := 'J';
                                   ;   TRANSLATE(.66.) := 'K';
                                   ;   TRANSLATE(.67.) := 'L';
                                   ;   TRANSLATE(.68.) := 'M';
                                   ;   TRANSLATE(.69.) := 'N';
                                   ;   TRANSLATE(.70.) := 'O';
                                   ;   TRANSLATE(.71.) := 'P';
                                   ;   TRANSLATE(.72.) := 'Q';
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.73.) := SUBCHAR;
                                   ;   TRANSLATE(.74.) := SUBCHAR;
        .ASCII /$*);^R/            ;   TRANSLATE(.75.) := '$';
                                   ;   TRANSLATE(.76.) := '*';
                                   ;   TRANSLATE(.77.) := ')';
                                   ;   TRANSLATE(.78.) := ';';
                                   ;   TRANSLATE(.79.) := '^';
                                   ;   TRANSLATE(.80.) := 'R';
        .REPT  23.                 ;   FOR I := 81 TO 127 DO
        .ASCII <SUBC30><SUBC30>    ;   TRANSLATE(.I.) := SUBCHAR;
        .ENDR                      ;
        .ASCII <SUBC30>            ;
                                   ; END "OF INITIALIZE";
                                   ;
                                   ;
INIT30:                            ; BEGIN
        MOV    #STAT30,DEVR39      ;   CONNECTED := DEVICEPRESENT(
        JSR    PC,DEVI39           ;                         STATUSREG);
        MOV    DEV39R,CONN30       ;
        BEQ    1$                  ;   IF CONNECTED THEN
        JSR    PC,INIZ30           ;     INITIALIZE;
1$:     RTS    PC                  ; END "OF CD11ACARDREADER";
                                   ;
                                   ;
        .SBTTL COMMON I/O CONTROL
                                   ;"###################################
                                   ;                  #  IO/INTERRUPT  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY IO(VAR BUFFER:
                                   ;                         BUFFERTYPE;
                                   ;                    VAR PARAM:
                                   ;                           @IOPARAM;
                                   ;                    DEVICE:
                                   ;                          IODEVICE);
                                   ;
UNI031  =      0                   ; CONST UNIT0 = 0;
UNI131  =      2                   ;       UNIT1 = 2;
                                   ;
                                   ; VAR NODEVICE: BOOLEAN;
                                   ;
IO31:                              ; BEGIN
        STIO11                     ;   RUNNING.STARTIO;
                                   ;   NODEVICE := FALSE;
        MOV    #<HEAD11+PARAM1>,R0 ;
        MOV    (R0)+,R1            ;
        MOV    (R0)+,R2            ;
        MOV    (R0),R0             ;   CASE DEVICE OF
        ASL    R0                  ;
        JMP    1$(R0)              ;
1$:     BR     2$                  ;
        BR     3$                  ;
        BR     4$                  ;
        BR     5$                  ;
        BR     6$                  ;
        BR     7$                  ;
2$:     TST    CONN28              ;     TTY0:
        BEQ    NODE31              ;     WITH LT33TERMINAL DO
        MOV    R1,BUF28            ;     IF CONNECTED THEN
        MOV    R2,COM28            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO28              ;       NODEVICE := TRUE;
                                   ;
3$:     TST    CONN27              ;     DISK0:
        BEQ    NODE31              ;     WITH RK11DISK DO
        MOV    R1,BUF27            ;     IF CONNECTED THEN
        MOV    R2,COM27            ;       INITIO(BUFFER, PARAM, UNIT0)
        CLR    UNIN27              ;       ELSE NODEVICE := TRUE;
        JMP    INIO27              ;
                                   ;
4$:     CLR    UNIN25              ;     TAPE90:
41$:    TST    CONN25              ;     WITH TM11TAPE DO
        BEQ    NODE31              ;     IF CONNECTED THEN
        MOV    R1,BUF25            ;       INITIO(BUFFER, PARAM, UNIT0)
        MOV    R2,COM25            ;       ELSE NODEVICE := TRUE;
        JMP    INIO25              ;
                                   ;
5$:     TST    CONN29              ;     PRINTER0:
        BEQ    NODE31              ;     WITH LPXXPRINTER DO
        MOV    R1,BUF29            ;     IF CONNECTED THEN
        MOV    R2,COM29            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO29              ;       NODEVICE := TRUE;
                                   ;
6$:     TST    CONN30              ;     CARDREADER0:
        BEQ    NODE31              ;     WITH CD11ACARDREADER DO
        MOV    R1,BUF30            ;     IF CONNECTED THEN
        MOV    R2,COM30            ;       INITIO(BUFFER, PARAM) ELSE
        JMP    INIO30              ;       NODEVICE := TRUE;
                                   ;
7$:                                ;     TAPE91:
        MOV    #UNI131,UNIN25      ;     WITH TM11TAPE DO
        BR     41$                 ;     IF CONNECTED THEN
                                   ;       INITIO(BUFFER, PARAM, UNIT1)
                                   ;       ELSE NODEVICE := TRUE;
                                   ;
                                   ;   END;
NODE31: MOV    R2,PARA38           ;   IF NODEVICE THEN
        JMP    IOFA38              ;     IOFAIL(PARAM);
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE ENTRY INTERRUPT(DEVICE:
                                   ;                          IODEVICE);
                                   ; BEGIN
                                   ;   CASE DEVICE OF
                                   ;     TTY0:
                                   ;       WITH LT33TERMINAL DO
                                   ;       CASE STATE OF
LTIN32: 		           ;         PASSIVE, READING:
        INTSRV RINT28              ;<01>                  READINTERRUPT;

LTOU32:                            ;<01>     WRITING: WRITEINTERRUPT;
        INTSRV WINT28              ;<01>    END;

RKIN32:                            ;<01> DISK0: RK11DISK.INTERRUPT;
        INTSRV INTE27              ;<01>

TMIN32:                            ;<01> TAPE90, TAPE91:
        INTSRV INTE25              ;<01>             TM11TAPE.INTERRUPT;

LPIN32:                            ;<01> PRINTER0:
        INTSRV INTE29              ;<01>          LPXXPRINTER.INTERRUPT;

CDIN32:			           ;<01> CARDREADER0:
        INTSRV INTE30              ;<01>      CD11ACARDREADER.INTERRUPT;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
        .SBTTL MESSAGE WRITERS
                                   ;"###################################
                                   ;                      #  MESSAGES  #
                                   ;###################################"
                                   ;
                                   ;
NEWL35: .ASCIZ <13.><10.>          ; CONST NEWLINE =
        .EVEN                      ;                '(:13:)(:10:)(:0:)';
                                   ;
                                   ; TYPE LINE = UNIV STRING;
                                   ;
                                   ;
TEXT33: .BLKB  .ADDRESS            ; PROCEDURE WRITETEXT(TEXT: @LINE);
                                   ;
NULC33  =      0                   ; CONST NULCHAR = '(:0:)';
                                   ;
I33:    .BLKB  .ADDRESS            ; VAR I: INTEGER;
                                   ;
WRIT33:                            ; BEGIN
        MOV    TEXT33,I33          ;   I := 1;
1$:     MOV    I33,R0              ;   WHILE NOT (TEXT@(.I.) = NULCHAR)
        MOVB   (R0)+,R1            ;                                  DO
        BNE    2$                  ;
        RTS    PC                  ;
2$:     MOV    R0,I33              ;   BEGIN
        MOV    R1,CHR28            ;     LT33TERMINAL.KERNELWRITE(
        JSR    PC,KERN28           ;                        TEXT@(.I.));
        BR     1$                  ;     I :+ 1;
                                   ;   END;
                                   ; END;
                                   ;
                                   ;
NN34:   .BLKB  .INTEGER            ; PROCEDURE WRITEINT(NN: INTEGER);
                                   ;
BLAN34  =      '                   ; CONST BLANK = ' ';
NULC34  =      0                   ;       NULCHAR = '(:0:)';
ZERO34  =      '0                  ;
                                   ;
;N      IS     R0, R1              ; VAR N: INTEGER;
;I      IS     R2                  ;     I: INTEGER;
INT34:  .ASCIZ /012345/            ;     INT: ARRAY (.1..7.) OF CHAR;
        .EVEN                      ;
WRIT34:                            ; BEGIN
                                   ;   INT(.7.) := NULCHAR;
        MOV    NN34,R1             ;   N := NN;
        MOV    #<INT34+6>,R2       ;   I := 7;
                                   ;   REPEAT
1$:     CLR    R0                  ;     I :- 1;
        DIV    #10.,R0             ;     INT(.I.) := CHR(N MOD 10 +
        ADD    #ZERO34,R1          ;                          ORD('0'));
        MOVB   R1,-(R2)            ;
        MOV    R0,R1               ;     N := N DIV 10;
        BNE    1$                  ;   UNTIL N = 0;
        MOVB   #BLAN34,-(R2)       ;   I :- 1;
                                   ;   INT(.I.) := BLANK;
        MOV    R2,TEXT33           ;   WRITETEXT(@INT(.I.));
        JSR    PC,WRIT33           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
RESU19: .BLKB  .INTEGER            ; PROCEDURE KERNELERROR(RESULT:
                                   ;                              LINE);
SYST19: .ASCIZ /SYSTEM LINE/       ; CONST SYSTEM = 'SYSTEM LINE(:0:)';
BLAN19: .ASCIZ / /                 ;       BLANK = ' (:0:)';
        .EVEN                      ;
KERN19:                            ; BEGIN
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        MOV    #SYST19,TEXT33      ;   WRITETEXT(SYSTEM);
        JSR    PC,WRIT33           ;
        MOV    HEAD11+OPLIN1,NN34  ;   WRITEINT(RUNNING.HEAD.OPLINE);
        JSR    PC,WRIT34           ;
        MOV    #BLAN19,TEXT33      ;   WRITETEXT(BLANK);
        JSR    PC,WRIT33           ;
        MOV    RESU19,TEXT33       ;   WRITETEXT(RESULT);
        JSR    PC,WRIT33           ;
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        HALT                       ;   CYCLE END;
        SYSERR                     ;
                                   ; END;
                                   ;
                                   ;
                                   ; PROCEDURE KERNELREADY;
                                   ;
READ37: .ASCIZ /SYSTEM READY/      ; CONST READYMESSAGE =
        .EVEN                      ;                'SYSTEM READY(:0:)';
                                   ;
KERN37:                            ; BEGIN
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        MOV    #READ37,TEXT33      ;   WRITETEXT(READYMESSAGE);
        JSR    PC,WRIT33           ;
        MOV    #NEWL35,TEXT33      ;   WRITETEXT(NEWLINE);
        JSR    PC,WRIT33           ;
        RTS    PC                  ; END;
                                   ;
                                   ;
        .SBTTL KERNEL INITIALIZATION
                                   ;"###################################
                                   ;                #  INITIALIZATION  #
                                   ;###################################"
                                   ;
                                   ;
                                   ; "INITIALIZE THE KERNEL"
                                   ;
INIT36:                            ; BEGIN
; THE CODE FOR THESE STANDARD PRO- ;   LOADVIRTUALMACHINE;
; CEDURES IS TO BE FOUND IN THE    ;   LOADSYSTEMPROGRAM;
; PROCESSOR DEFINITION PREFIX OF   ;
; THIS PROGRAM.  IT IS INVOKED AS  ;
; PART OF THE INITIAL PROGRAM LOAD-;
; ING BY MEANS OF A JUMP TO ADDRESS;
; ZERO.                            ;
                                   ;
        JSR    PC,INIT16           ;   NEWCORE.INITIALIZE;
        JSR    PC,INIT6            ;   TIMER.INITIALIZE;
        JSR    PC,INIT7            ;   CLOCK.INITIALIZE;
        JSR    PC,INIT9            ;   CORE.INITIALIZE;
        JSR    PC,INIT10           ;   VIRTUAL.INITIALIZE;
        JSR    PC,INIT11           ;   RUNNING.INITIALIZE;
        JSR    PC,INIT12           ;   READY.INITIALIZE;
        JSR    PC,INIT25           ;   TM11TAPE.INITIALIZE;
        JSR    PC,INIT27           ;   RK11DISK.INITIALIZE;
        JSR    PC,INIT28           ;   LT33TERMINAL.INITIALIZE;
        JSR    PC,INIT29           ;   LPXXPRINTER.INITIALIZE;
        JSR    PC,INIT30           ;   CD11ACARDREADER.INITIALIZE;
                                   ;
        MOV    INTL99,INTL11       ;   RUNNING.INITPARENT(
        JSR    PC,INPA11           ;                 INTERPRETERLENGTH);
        JSR    PC,KERN37           ;   KERNELREADY;
        RTS    PC                  ; END "OF KERNEL";
                                   ;
                                   ;
        .SBTTL
        .SBTTL #########################################################
        .SBTTL
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 